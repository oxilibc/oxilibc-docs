<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Oxilibc: target/include/string.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Oxilibc
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('string_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">string.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="target_2include_2stddef_8h_source.html">stddef.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="target_2include_2stdint_8h_source.html">stdint.h</a>&gt;</code><br />
</div>
<p><a href="string_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aec99b54bbc0bfcbf79b931309e04e315"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#aec99b54bbc0bfcbf79b931309e04e315">memccpy</a> (void *dest, const void *src, int c, <a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> len)</td></tr>
<tr class="memdesc:aec99b54bbc0bfcbf79b931309e04e315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy bytes from <code>src</code> to <code>dest</code> until <code>c</code> byte is found, returning a pointer to the byte after the position of <code>c</code> in <code>dest</code>, or until <code>len</code> bytes are copied, returning a NULL pointer.  <a href="string_8h.html#aec99b54bbc0bfcbf79b931309e04e315">More...</a><br /></td></tr>
<tr class="separator:aec99b54bbc0bfcbf79b931309e04e315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea35f46af5016d8f7394c60392edcf3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#adea35f46af5016d8f7394c60392edcf3">memchr</a> (const void *src, int byte, <a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> len)</td></tr>
<tr class="memdesc:adea35f46af5016d8f7394c60392edcf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first occurrence of a <code>byte</code> in a <code>source</code> first <code>len</code> bytes, returning a pointer to the found the <code>byte</code> or a null pointer it the <code>byte</code> was not found.  <a href="string_8h.html#adea35f46af5016d8f7394c60392edcf3">More...</a><br /></td></tr>
<tr class="separator:adea35f46af5016d8f7394c60392edcf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64130158a302f226bf5602408d0f988a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a64130158a302f226bf5602408d0f988a">memcmp</a> (const void *src, const void *other, <a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> len)</td></tr>
<tr class="memdesc:a64130158a302f226bf5602408d0f988a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first <code>len</code> bytes of the objects pointed to by <code>source</code> and <code>other</code> and returning:  <a href="string_8h.html#a64130158a302f226bf5602408d0f988a">More...</a><br /></td></tr>
<tr class="separator:a64130158a302f226bf5602408d0f988a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2cb14f63e73acc45996f71718121b1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#aee2cb14f63e73acc45996f71718121b1">memcpy</a> (void *dest, const void *src, <a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> len)</td></tr>
<tr class="memdesc:aee2cb14f63e73acc45996f71718121b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first <code>len</code> bytes from <code>src</code> to <code>dest</code>, returning <code>dest</code> itself.  <a href="string_8h.html#aee2cb14f63e73acc45996f71718121b1">More...</a><br /></td></tr>
<tr class="separator:aee2cb14f63e73acc45996f71718121b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e38d29e82f8674d4db22e2a52a66144"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a9e38d29e82f8674d4db22e2a52a66144">memmem</a> (const void *src, <a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> str_len, const void *pattern, <a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> pattern_len)</td></tr>
<tr class="memdesc:a9e38d29e82f8674d4db22e2a52a66144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first occurrence of a <code>pattern</code> of <code>pattern_len</code> size in a <code>src</code> first <code>len</code> bytes, returning a pointer to the first byte of the found <code>pattern</code> or a null pointer it the <code>pattern</code> was not found.  <a href="string_8h.html#a9e38d29e82f8674d4db22e2a52a66144">More...</a><br /></td></tr>
<tr class="separator:a9e38d29e82f8674d4db22e2a52a66144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4522f53cff2fef09001e4d34227463a9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a4522f53cff2fef09001e4d34227463a9">memmove</a> (void *dest, const void *src, <a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> len)</td></tr>
<tr class="memdesc:a4522f53cff2fef09001e4d34227463a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first <code>len</code> bytes from <code>src</code> to <code>dest</code>, returning <code>dest</code>.  <a href="string_8h.html#a4522f53cff2fef09001e4d34227463a9">More...</a><br /></td></tr>
<tr class="separator:a4522f53cff2fef09001e4d34227463a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f8ade3a284c772cc1dec54f6ab8ba9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#af9f8ade3a284c772cc1dec54f6ab8ba9">memrchr</a> (const void *src, int byte, <a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> len)</td></tr>
<tr class="memdesc:af9f8ade3a284c772cc1dec54f6ab8ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last occurrence of a <code>byte</code> in a <code>source</code> first <code>len</code> bytes, returning a pointer to the found the <code>byte</code> or a null pointer it the <code>byte</code> was not found.  <a href="string_8h.html#af9f8ade3a284c772cc1dec54f6ab8ba9">More...</a><br /></td></tr>
<tr class="separator:af9f8ade3a284c772cc1dec54f6ab8ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b5b83eb62b0464430efe64b854478d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#ac1b5b83eb62b0464430efe64b854478d">memrmem</a> (const void *src, <a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> str_len, const void *pattern, <a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> pattern_len)</td></tr>
<tr class="memdesc:ac1b5b83eb62b0464430efe64b854478d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last occurrence of a <code>pattern</code> of <code>pattern_len</code> size in a <code>src</code> first <code>len</code> bytes, returning a pointer to the first byte of the found <code>pattern</code> or a null pointer it the <code>pattern</code> was not found.  <a href="string_8h.html#ac1b5b83eb62b0464430efe64b854478d">More...</a><br /></td></tr>
<tr class="separator:ac1b5b83eb62b0464430efe64b854478d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be6b050df320ba946ee4acf53756090"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a8be6b050df320ba946ee4acf53756090">memset</a> (void *src, int val, <a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> len)</td></tr>
<tr class="memdesc:a8be6b050df320ba946ee4acf53756090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the first <code>len</code> bytes of <code>src</code> to the value of <code>val</code>, returning the <code>src</code>.  <a href="string_8h.html#a8be6b050df320ba946ee4acf53756090">More...</a><br /></td></tr>
<tr class="separator:a8be6b050df320ba946ee4acf53756090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78660f2f08a94fbb9f194f69b29d26e5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a78660f2f08a94fbb9f194f69b29d26e5">stpcpy</a> (char *dest, const char *src)</td></tr>
<tr class="memdesc:a78660f2f08a94fbb9f194f69b29d26e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the characters from the <code>src</code> string to the <code>dest</code>, returning a pointer to the end of the string, in other words, the first null character.  <a href="string_8h.html#a78660f2f08a94fbb9f194f69b29d26e5">More...</a><br /></td></tr>
<tr class="separator:a78660f2f08a94fbb9f194f69b29d26e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf46d1a41f073640eee9762ebe58f511"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#abf46d1a41f073640eee9762ebe58f511">stpncpy</a> (char *dest, const char *src, <a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> max_size)</td></tr>
<tr class="memdesc:abf46d1a41f073640eee9762ebe58f511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the at least <code>max_size</code> characters from the <code>src</code> string to the <code>dest</code>, returning a pointer to the end of the string, in other words, the first null character.  <a href="string_8h.html#abf46d1a41f073640eee9762ebe58f511">More...</a><br /></td></tr>
<tr class="separator:abf46d1a41f073640eee9762ebe58f511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19546e43db31c3095991b04023b422b2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a19546e43db31c3095991b04023b422b2">strcat</a> (char *dest, const char *src)</td></tr>
<tr class="memdesc:a19546e43db31c3095991b04023b422b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a copy of the <code>src</code> string to the <code>dest</code> string, returning a pointer to the beginning of the <code>dest</code> string.  <a href="string_8h.html#a19546e43db31c3095991b04023b422b2">More...</a><br /></td></tr>
<tr class="separator:a19546e43db31c3095991b04023b422b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0592e0e4baf26a4bffbe49168e887fa"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#ab0592e0e4baf26a4bffbe49168e887fa">strchr</a> (const char *str, int ch)</td></tr>
<tr class="memdesc:ab0592e0e4baf26a4bffbe49168e887fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first occurrence of a <code>ch</code> in a <code>str</code>, returning a pointer to the found the <code>ch</code> or a null pointer it the <code>ch</code> was not found.  <a href="string_8h.html#ab0592e0e4baf26a4bffbe49168e887fa">More...</a><br /></td></tr>
<tr class="separator:ab0592e0e4baf26a4bffbe49168e887fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3dcb20ff11ff9db5904c3cfb61a38c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a6f3dcb20ff11ff9db5904c3cfb61a38c">strcmp</a> (const char *str1, const char *str2)</td></tr>
<tr class="memdesc:a6f3dcb20ff11ff9db5904c3cfb61a38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <code>str1</code> and <code>str2</code> null terminated strings lexicographically.  <a href="string_8h.html#a6f3dcb20ff11ff9db5904c3cfb61a38c">More...</a><br /></td></tr>
<tr class="separator:a6f3dcb20ff11ff9db5904c3cfb61a38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5082c8ce4f0cddd88bf4d0d2e738308"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#ac5082c8ce4f0cddd88bf4d0d2e738308">strcpy</a> (char *dest, const char *src)</td></tr>
<tr class="memdesc:ac5082c8ce4f0cddd88bf4d0d2e738308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the <code>src</code> string, including the null terminator, to the <code>dest</code>, returning <code>dest</code> itself.  <a href="string_8h.html#ac5082c8ce4f0cddd88bf4d0d2e738308">More...</a><br /></td></tr>
<tr class="separator:ac5082c8ce4f0cddd88bf4d0d2e738308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bc3c17235693515008ea0cda14260f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a28bc3c17235693515008ea0cda14260f">strcspn</a> (const char *str, const char *char_set)</td></tr>
<tr class="memdesc:a28bc3c17235693515008ea0cda14260f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment (span) of the byte string pointed to by <code>str</code>, that consists of only the characters <em>not</em> found in the byte string pointed to by <code>char_set</code>.  <a href="string_8h.html#a28bc3c17235693515008ea0cda14260f">More...</a><br /></td></tr>
<tr class="separator:a28bc3c17235693515008ea0cda14260f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008e171a518fe0e0352f31b245e03875"><td class="memItemLeft" align="right" valign="top"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a008e171a518fe0e0352f31b245e03875">strlen</a> (const char *str)</td></tr>
<tr class="memdesc:a008e171a518fe0e0352f31b245e03875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the given null terminated string <code>str</code>.  <a href="string_8h.html#a008e171a518fe0e0352f31b245e03875">More...</a><br /></td></tr>
<tr class="separator:a008e171a518fe0e0352f31b245e03875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae917df9af66d8bbc84e3aaeaf8e34d3a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#ae917df9af66d8bbc84e3aaeaf8e34d3a">strncat</a> (char *dest, const char *src, <a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> max_size)</td></tr>
<tr class="memdesc:ae917df9af66d8bbc84e3aaeaf8e34d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a copy of the <code>src</code> string to the <code>dest</code> string for at least <code>max_size</code> characters, returning a pointer to the beginning of the <code>dest</code> string.  <a href="string_8h.html#ae917df9af66d8bbc84e3aaeaf8e34d3a">More...</a><br /></td></tr>
<tr class="separator:ae917df9af66d8bbc84e3aaeaf8e34d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872192e0a38d54c47a8722938d8ce558"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a872192e0a38d54c47a8722938d8ce558">strncmp</a> (const char *str1, const char *str2, <a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> max_size)</td></tr>
<tr class="memdesc:a872192e0a38d54c47a8722938d8ce558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <code>str1</code> and <code>str2</code> for a maximum of <code>max_size</code> strings lexicographically.  <a href="string_8h.html#a872192e0a38d54c47a8722938d8ce558">More...</a><br /></td></tr>
<tr class="separator:a872192e0a38d54c47a8722938d8ce558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba79b932727a6e399a68c3a88dcfa93"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a4ba79b932727a6e399a68c3a88dcfa93">strncpy</a> (char *dest, const char *src, <a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> max_size)</td></tr>
<tr class="memdesc:a4ba79b932727a6e399a68c3a88dcfa93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the at least <code>max_size</code> characters from the <code>src</code> string to the <code>dest</code>, returning <code>dest</code> itself.  <a href="string_8h.html#a4ba79b932727a6e399a68c3a88dcfa93">More...</a><br /></td></tr>
<tr class="separator:a4ba79b932727a6e399a68c3a88dcfa93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bb92bca4cc2ef4c7b93550270a949c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#af1bb92bca4cc2ef4c7b93550270a949c">strnlen</a> (const char *str, <a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> max_size)</td></tr>
<tr class="memdesc:af1bb92bca4cc2ef4c7b93550270a949c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A safer version of [strlen].  <a href="string_8h.html#af1bb92bca4cc2ef4c7b93550270a949c">More...</a><br /></td></tr>
<tr class="separator:af1bb92bca4cc2ef4c7b93550270a949c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3135fe411f8507e490704184fbecc697"><td class="memItemLeft" align="right" valign="top"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a3135fe411f8507e490704184fbecc697">strnlen_s</a> (const char *str, <a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> max_size)</td></tr>
<tr class="memdesc:a3135fe411f8507e490704184fbecc697"><td class="mdescLeft">&#160;</td><td class="mdescRight">A safer version of [strlen].  <a href="string_8h.html#a3135fe411f8507e490704184fbecc697">More...</a><br /></td></tr>
<tr class="separator:a3135fe411f8507e490704184fbecc697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7662d17f7904c19e871728691d0cb303"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a7662d17f7904c19e871728691d0cb303">strrchr</a> (const char *str, int ch)</td></tr>
<tr class="memdesc:a7662d17f7904c19e871728691d0cb303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last occurrence of a <code>ch</code> in a <code>str</code>, returning a pointer to the found the <code>ch</code> or a null pointer it the <code>ch</code> was not found.  <a href="string_8h.html#a7662d17f7904c19e871728691d0cb303">More...</a><br /></td></tr>
<tr class="separator:a7662d17f7904c19e871728691d0cb303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06aea5f2e42c34e773726a0031c7a19f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a06aea5f2e42c34e773726a0031c7a19f">strspn</a> (const char *str, const char *char_set)</td></tr>
<tr class="memdesc:a06aea5f2e42c34e773726a0031c7a19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment (span) of the byte string pointed to by <code>str</code>, that consists of only the characters found in the byte string pointed to by <code>char_set</code>.  <a href="string_8h.html#a06aea5f2e42c34e773726a0031c7a19f">More...</a><br /></td></tr>
<tr class="separator:a06aea5f2e42c34e773726a0031c7a19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e41d07110225e8405824ae1cfb26c66"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a6e41d07110225e8405824ae1cfb26c66">strstr</a> (const char *str, const char *pattern)</td></tr>
<tr class="memdesc:a6e41d07110225e8405824ae1cfb26c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first occurrence of a <code>pattern</code> in a <code>src</code>, returning a pointer to the first character of the found the <code>pattern</code> or a null pointer it the <code>pattern</code> was not found.  <a href="string_8h.html#a6e41d07110225e8405824ae1cfb26c66">More...</a><br /></td></tr>
<tr class="separator:a6e41d07110225e8405824ae1cfb26c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aec99b54bbc0bfcbf79b931309e04e315" name="aec99b54bbc0bfcbf79b931309e04e315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec99b54bbc0bfcbf79b931309e04e315">&#9670;&nbsp;</a></span>memccpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memccpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy bytes from <code>src</code> to <code>dest</code> until <code>c</code> byte is found, returning a pointer to the byte after the position of <code>c</code> in <code>dest</code>, or until <code>len</code> bytes are copied, returning a NULL pointer. </p>
<h1><a class="anchor" id="autotoc_md6"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>src</code> must be valid for reads of <code>len</code> bytes.</li>
<li><code>dest</code> must be valid for writes of <code>len</code> bytes.</li>
<li>The region of memory beginning at <code>src</code> with a size of <code>len</code> bytes must <em>not</em> overlap with the region of memory beginning at <code>dest</code> with the same size.</li>
<li><code>c</code> must be a valid <code>u8</code> value.</li>
</ul>
<h1><a class="anchor" id="autotoc_md7"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md8"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxilibc::string::memccpy;</div>
<div class="line"> </div>
<div class="line">let src = [1u8, 2, 3, 4, 5];</div>
<div class="line">let mut dest = [0u8; 5];</div>
<div class="line"> </div>
<div class="line">let ptr = unsafe { memccpy(dest.as_mut_ptr() as _, src.as_ptr() as _, 3, 5) };</div>
<div class="line">assert_eq!(ptr, dest[3..].as_ptr() as _);</div>
<div class="line">assert_eq!(dest, [1u8, 2, 3, 0, 0]);</div>
</div><!-- fragment --><div class="fragment"><div class="line">use oxilibc::string::memccpy;</div>
<div class="line"> </div>
<div class="line">let src = [1u8, 2, 3, 4, 5];</div>
<div class="line">let mut dest = [0u8; 5];</div>
<div class="line"> </div>
<div class="line">let ptr = unsafe { memccpy(dest.as_mut_ptr() as _, src.as_ptr() as _, 7, 5) };</div>
<div class="line">assert!(ptr.is_null());</div>
<div class="line">assert_eq!(dest, [1u8, 2, 3, 4, 5]);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> src[] = {1, 2, 3, 4, 5};</div>
<div class="line">    <span class="keywordtype">char</span>* dest = {0,0,0,0,0};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span>* ptr = <a class="code hl_function" href="string_8h.html#aec99b54bbc0bfcbf79b931309e04e315">memccpy</a>(dest, src, 3, 5);</div>
<div class="line">    assert(<a class="code hl_function" href="string_8h.html#a64130158a302f226bf5602408d0f988a">memcmp</a>(dest, src, 3));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html"><div class="ttname"><a href="string_8h.html">string.h</a></div></div>
<div class="ttc" id="astring_8h_html_a64130158a302f226bf5602408d0f988a"><div class="ttname"><a href="string_8h.html#a64130158a302f226bf5602408d0f988a">memcmp</a></div><div class="ttdeci">int memcmp(const void *src, const void *other, size_t len)</div><div class="ttdoc">Compares the first len bytes of the objects pointed to by source and other and returning:</div></div>
<div class="ttc" id="astring_8h_html_aec99b54bbc0bfcbf79b931309e04e315"><div class="ttname"><a href="string_8h.html#aec99b54bbc0bfcbf79b931309e04e315">memccpy</a></div><div class="ttdeci">void * memccpy(void *dest, const void *src, int c, size_t len)</div><div class="ttdoc">Copy bytes from src to dest until c byte is found, returning a pointer to the byte after the position...</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> src[] = {1, 2, 3, 4, 5};</div>
<div class="line">    <span class="keywordtype">char</span>* dest = {0,0,0,0,0};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span>* ptr = <a class="code hl_function" href="string_8h.html#aec99b54bbc0bfcbf79b931309e04e315">memccpy</a>(dest, src, 7, 5);</div>
<div class="line">    assert(NULL == ptr);</div>
<div class="line">    assert(<a class="code hl_function" href="string_8h.html#a64130158a302f226bf5602408d0f988a">memcmp</a>(dest, src, 5));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="adea35f46af5016d8f7394c60392edcf3" name="adea35f46af5016d8f7394c60392edcf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea35f46af5016d8f7394c60392edcf3">&#9670;&nbsp;</a></span>memchr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memchr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the first occurrence of a <code>byte</code> in a <code>source</code> first <code>len</code> bytes, returning a pointer to the found the <code>byte</code> or a null pointer it the <code>byte</code> was not found. </p>
<h1><a class="anchor" id="autotoc_md10"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>src</code> must be valid for reads of <code>len</code> bytes.</li>
</ul>
<h1><a class="anchor" id="autotoc_md11"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md12"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxilibc::string::memchr;</div>
<div class="line"> </div>
<div class="line">let arr = [10, 12, 45, 78, 32];</div>
<div class="line"> </div>
<div class="line">let found_at_ptr = unsafe { memchr(arr.as_ptr() as _, 12, arr.len()) };</div>
<div class="line"> </div>
<div class="line">assert_eq!(found_at_ptr, arr[1..].as_ptr() as _);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md13"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> arr[] = {10, 12, 45, 78, 32};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span>* ptr = <a class="code hl_function" href="string_8h.html#adea35f46af5016d8f7394c60392edcf3">memchr</a>(arr, 12, 5);</div>
<div class="line">    assert(ptr == arr[1]);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_adea35f46af5016d8f7394c60392edcf3"><div class="ttname"><a href="string_8h.html#adea35f46af5016d8f7394c60392edcf3">memchr</a></div><div class="ttdeci">void * memchr(const void *src, int byte, size_t len)</div><div class="ttdoc">Search for the first occurrence of a byte in a source first len bytes, returning a pointer to the fou...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a64130158a302f226bf5602408d0f988a" name="a64130158a302f226bf5602408d0f988a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64130158a302f226bf5602408d0f988a">&#9670;&nbsp;</a></span>memcmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int memcmp </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the first <code>len</code> bytes of the objects pointed to by <code>source</code> and <code>other</code> and returning: </p>
<ul>
<li>Zero if both pointed objects are the same</li>
<li>A positive number if <code>source</code> is greater than <code>other</code></li>
<li>A negative number if <code>source</code> is less than <code>other</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md14"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>src</code> must be valid for reads of <code>len</code> bytes.</li>
<li><code>other</code> must be valid for reads of <code>len</code> bytes.</li>
</ul>
<h1><a class="anchor" id="autotoc_md15"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md16"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxilibc::string::memcmp;</div>
<div class="line"> </div>
<div class="line">let source = b&quot;Hello,&quot;;</div>
<div class="line">let other = b&quot;World&quot;;</div>
<div class="line"> </div>
<div class="line">let len = source.len().min(other.len());</div>
<div class="line">let ord = unsafe { memcmp(source.as_ptr() as _, other.as_ptr() as _, len) };</div>
<div class="line"> </div>
<div class="line">assert!(ord &lt; 0);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md17"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> source[] = <span class="stringliteral">&quot;Hello,&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> other[]  = <span class="stringliteral">&quot;World&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> ord = <a class="code hl_function" href="string_8h.html#a64130158a302f226bf5602408d0f988a">memcmp</a>(source, other, 5);</div>
<div class="line">    assert(ord &lt; 0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aee2cb14f63e73acc45996f71718121b1" name="aee2cb14f63e73acc45996f71718121b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2cb14f63e73acc45996f71718121b1">&#9670;&nbsp;</a></span>memcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the first <code>len</code> bytes from <code>src</code> to <code>dest</code>, returning <code>dest</code> itself. </p>
<h1><a class="anchor" id="autotoc_md18"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>src</code> must be valid for reads of <code>len</code> bytes.</li>
<li><code>dest</code> must be valid for writes of <code>len</code> bytes.</li>
<li>The region of memory beginning at <code>src</code> with a size of <code>len</code> bytes must <em>not</em> overlap with the region of memory beginning at <code>dest</code> with the same size.</li>
</ul>
<h1><a class="anchor" id="autotoc_md19"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md20"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxilibc::string::memcpy;</div>
<div class="line"> </div>
<div class="line">let src = [1u8, 2, 3, 4, 5];</div>
<div class="line">let mut dest = [0u8; 5];</div>
<div class="line"> </div>
<div class="line">unsafe {</div>
<div class="line">    memcpy(dest.as_mut_ptr() as _, src.as_ptr() as _, 5);</div>
<div class="line">}</div>
<div class="line">assert_eq!(dest, [1u8, 2, 3, 4, 5]);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> src[] = {1, 2, 3, 4, 5};</div>
<div class="line">    <span class="keywordtype">char</span>* dest = {0,0,0,0,0};</div>
<div class="line"> </div>
<div class="line">    assert(<a class="code hl_function" href="string_8h.html#a64130158a302f226bf5602408d0f988a">memcmp</a>(<a class="code hl_function" href="string_8h.html#aee2cb14f63e73acc45996f71718121b1">memcpy</a>(dest, src, 5), src, 5));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_aee2cb14f63e73acc45996f71718121b1"><div class="ttname"><a href="string_8h.html#aee2cb14f63e73acc45996f71718121b1">memcpy</a></div><div class="ttdeci">void * memcpy(void *dest, const void *src, size_t len)</div><div class="ttdoc">Copy the first len bytes from src to dest, returning dest itself.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9e38d29e82f8674d4db22e2a52a66144" name="a9e38d29e82f8674d4db22e2a52a66144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e38d29e82f8674d4db22e2a52a66144">&#9670;&nbsp;</a></span>memmem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memmem </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>str_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>pattern_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the first occurrence of a <code>pattern</code> of <code>pattern_len</code> size in a <code>src</code> first <code>len</code> bytes, returning a pointer to the first byte of the found <code>pattern</code> or a null pointer it the <code>pattern</code> was not found. </p>
<h1><a class="anchor" id="autotoc_md22"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>src</code> must be valid for reads of <code>str_len</code> bytes.</li>
<li><code>pattern</code> must be valid for reads of <code>pattern_len</code> bytes.</li>
</ul>
<h1><a class="anchor" id="autotoc_md23"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md24"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxilibc::string::memmem;</div>
<div class="line"> </div>
<div class="line">let src = b&quot;abcdefghijklmnopqrstuvwxyz&quot;;</div>
<div class="line">let pat = b&quot;jk&quot;;</div>
<div class="line"> </div>
<div class="line">let ptr = unsafe {</div>
<div class="line">    memmem(</div>
<div class="line">        src.as_ptr().cast(),</div>
<div class="line">        src.len(),</div>
<div class="line">        pat.as_ptr().cast(),</div>
<div class="line">        pat.len(),</div>
<div class="line">    )</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">assert_eq!(ptr, src[9..].as_ptr());</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md25"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* src = <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* pat = <span class="stringliteral">&quot;jk&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    assert(<a class="code hl_function" href="string_8h.html#a64130158a302f226bf5602408d0f988a">memcmp</a>(<a class="code hl_function" href="string_8h.html#a9e38d29e82f8674d4db22e2a52a66144">memmem</a>(src, 26, pat, 2), <span class="stringliteral">&quot;jk&quot;</span>, 2))</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_a9e38d29e82f8674d4db22e2a52a66144"><div class="ttname"><a href="string_8h.html#a9e38d29e82f8674d4db22e2a52a66144">memmem</a></div><div class="ttdeci">void * memmem(const void *src, size_t str_len, const void *pattern, size_t pattern_len)</div><div class="ttdoc">Search for the first occurrence of a pattern of pattern_len size in a src first len bytes,...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4522f53cff2fef09001e4d34227463a9" name="a4522f53cff2fef09001e4d34227463a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4522f53cff2fef09001e4d34227463a9">&#9670;&nbsp;</a></span>memmove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memmove </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the first <code>len</code> bytes from <code>src</code> to <code>dest</code>, returning <code>dest</code>. </p>
<p >Note that differently than <code>memcpy</code>, the slices of memory of <code>[src, src + len)</code> and <code>[dest, dest + len)</code> can overlap.</p>
<h1><a class="anchor" id="autotoc_md26"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>src</code> must be valid for reads of <code>len</code> bytes.</li>
<li><code>dest</code> must be valid for writes of <code>len</code> bytes.</li>
</ul>
<h1><a class="anchor" id="autotoc_md27"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md28"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxilibc::string::memmove;</div>
<div class="line"> </div>
<div class="line">let mut src = [1u8, 2, 3, 4, 5];</div>
<div class="line">let src2 = [125u8, 124, 122];</div>
<div class="line">let p1 = src.as_mut_ptr();</div>
<div class="line">let p2 = src2.as_ptr();</div>
<div class="line">unsafe { memmove(p1.cast(), p2.cast(), src2.len() as _) };</div>
<div class="line">assert_eq!(src, [125, 124, 122, 4, 5]);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md29"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keywordtype">char</span>* src = <span class="stringliteral">&quot;abcde&quot;</span>;</div>
<div class="line">    <span class="keywordtype">char</span>* dest = <span class="stringliteral">&quot;FGH&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    assert(<a class="code hl_function" href="string_8h.html#a64130158a302f226bf5602408d0f988a">memcmp</a>(<a class="code hl_function" href="string_8h.html#a4522f53cff2fef09001e4d34227463a9">memmove</a>(dest, src, 3), <span class="stringliteral">&quot;FGHde&quot;</span>, 6));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_a4522f53cff2fef09001e4d34227463a9"><div class="ttname"><a href="string_8h.html#a4522f53cff2fef09001e4d34227463a9">memmove</a></div><div class="ttdeci">void * memmove(void *dest, const void *src, size_t len)</div><div class="ttdoc">Copy the first len bytes from src to dest, returning dest.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af9f8ade3a284c772cc1dec54f6ab8ba9" name="af9f8ade3a284c772cc1dec54f6ab8ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f8ade3a284c772cc1dec54f6ab8ba9">&#9670;&nbsp;</a></span>memrchr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memrchr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the last occurrence of a <code>byte</code> in a <code>source</code> first <code>len</code> bytes, returning a pointer to the found the <code>byte</code> or a null pointer it the <code>byte</code> was not found. </p>
<h1><a class="anchor" id="autotoc_md30"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>src</code> must be valid for reads of <code>len</code> bytes.</li>
</ul>
<h1><a class="anchor" id="autotoc_md31"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md32"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxilibc::string::memrchr;</div>
<div class="line"> </div>
<div class="line">let arr = [10, 12, 45, 12, 32];</div>
<div class="line"> </div>
<div class="line">let found_at_ptr = unsafe { memrchr(arr.as_ptr() as _, 12, arr.len()) };</div>
<div class="line"> </div>
<div class="line">assert_eq!(found_at_ptr, arr[3..].as_ptr() as _);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md33"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> arr[] = {10, 12, 45, 12, 32};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span>* ptr = <a class="code hl_function" href="string_8h.html#af9f8ade3a284c772cc1dec54f6ab8ba9">memrchr</a>(arr, 12, 5);</div>
<div class="line">    assert(ptr == arr[3]);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_af9f8ade3a284c772cc1dec54f6ab8ba9"><div class="ttname"><a href="string_8h.html#af9f8ade3a284c772cc1dec54f6ab8ba9">memrchr</a></div><div class="ttdeci">void * memrchr(const void *src, int byte, size_t len)</div><div class="ttdoc">Search for the last occurrence of a byte in a source first len bytes, returning a pointer to the foun...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac1b5b83eb62b0464430efe64b854478d" name="ac1b5b83eb62b0464430efe64b854478d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b5b83eb62b0464430efe64b854478d">&#9670;&nbsp;</a></span>memrmem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memrmem </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>str_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>pattern_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the last occurrence of a <code>pattern</code> of <code>pattern_len</code> size in a <code>src</code> first <code>len</code> bytes, returning a pointer to the first byte of the found <code>pattern</code> or a null pointer it the <code>pattern</code> was not found. </p>
<h1><a class="anchor" id="autotoc_md34"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>src</code> must be valid for reads of <code>str_len</code> bytes.</li>
<li><code>pattern</code> must be valid for reads of <code>pattern_len</code> bytes.</li>
</ul>
<h1><a class="anchor" id="autotoc_md35"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md36"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxilibc::string::memrmem;</div>
<div class="line"> </div>
<div class="line">let src = b&quot;abcdefghijklmnopqrstuvjkyz&quot;;</div>
<div class="line">let pat = b&quot;jk&quot;;</div>
<div class="line"> </div>
<div class="line">let ptr = unsafe {</div>
<div class="line">    memrmem(</div>
<div class="line">        src.as_ptr().cast(),</div>
<div class="line">        src.len(),</div>
<div class="line">        pat.as_ptr().cast(),</div>
<div class="line">        pat.len(),</div>
<div class="line">    )</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">assert_eq!(ptr, src[22..].as_ptr());</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md37"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* src = <span class="stringliteral">&quot;abcdefghijklmnopqrstuvjkyz&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* pat = <span class="stringliteral">&quot;jk&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    assert(<a class="code hl_function" href="string_8h.html#a64130158a302f226bf5602408d0f988a">memcmp</a>(<a class="code hl_function" href="string_8h.html#ac1b5b83eb62b0464430efe64b854478d">memrmem</a>(src, 26, pat, 2), <span class="stringliteral">&quot;jk&quot;</span>, 2))</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_ac1b5b83eb62b0464430efe64b854478d"><div class="ttname"><a href="string_8h.html#ac1b5b83eb62b0464430efe64b854478d">memrmem</a></div><div class="ttdeci">void * memrmem(const void *src, size_t str_len, const void *pattern, size_t pattern_len)</div><div class="ttdoc">Search for the last occurrence of a pattern of pattern_len size in a src first len bytes,...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8be6b050df320ba946ee4acf53756090" name="a8be6b050df320ba946ee4acf53756090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be6b050df320ba946ee4acf53756090">&#9670;&nbsp;</a></span>memset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the first <code>len</code> bytes of <code>src</code> to the value of <code>val</code>, returning the <code>src</code>. </p>
<h1><a class="anchor" id="autotoc_md38"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>src</code> must be valid for reads of <code>len</code> bytes.</li>
<li><code>src</code> must be valid for writes of <code>len</code> bytes.</li>
</ul>
<h1><a class="anchor" id="autotoc_md39"></a>
Example</h1>
<h2><a class="anchor" id="autotoc_md40"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxilibc::string::memset;</div>
<div class="line"> </div>
<div class="line">let mut src = [b&#39;a&#39;, b&#39;b&#39;, b&#39;c&#39;, b&#39;d&#39;, b&#39;e&#39;, b&#39;f&#39;];</div>
<div class="line"> </div>
<div class="line">unsafe {</div>
<div class="line">    memset(src.as_mut_ptr() as _, b&#39;g&#39; as _, 3);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">assert_eq!(&amp;src, b&quot;gggdef&quot;);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md41"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keywordtype">char</span>* src = <span class="stringliteral">&quot;abcdef&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    assert(<a class="code hl_function" href="string_8h.html#a64130158a302f226bf5602408d0f988a">memcmp</a>(<a class="code hl_function" href="string_8h.html#a8be6b050df320ba946ee4acf53756090">memset</a>(src, <span class="charliteral">&#39;g&#39;</span>, 3), <span class="stringliteral">&quot;gggdef&quot;</span>, 6));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_a8be6b050df320ba946ee4acf53756090"><div class="ttname"><a href="string_8h.html#a8be6b050df320ba946ee4acf53756090">memset</a></div><div class="ttdeci">void * memset(void *src, int val, size_t len)</div><div class="ttdoc">Set the first len bytes of src to the value of val, returning the src.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a78660f2f08a94fbb9f194f69b29d26e5" name="a78660f2f08a94fbb9f194f69b29d26e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78660f2f08a94fbb9f194f69b29d26e5">&#9670;&nbsp;</a></span>stpcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * stpcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the characters from the <code>src</code> string to the <code>dest</code>, returning a pointer to the end of the string, in other words, the first null character. </p>
<h1><a class="anchor" id="autotoc_md42"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>src</code> must be a null terminated string</li>
<li><code>dest</code> must be at least the size of <code>src</code> long</li>
<li><code>str</code> must be valid for reads until the first null character found.</li>
<li><code>dest</code> must be valid for writes until the <code>str</code> length.</li>
<li><code>src</code> and <code>dest</code> must not overlap</li>
</ul>
<h1><a class="anchor" id="autotoc_md43"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md44"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxibot::string::stpcpy;</div>
<div class="line"> </div>
<div class="line">let src = b&quot;Hello World!\0&quot;;</div>
<div class="line">let dest = &amp;mut [0u8; 13];</div>
<div class="line"> </div>
<div class="line">let ret = unsafe { stpcpy(dest.as_mut_ptr().cast(), src.as_ptr().cast()) };</div>
<div class="line">assert_eq!(src, dest);</div>
<div class="line"> </div>
<div class="line">let expected_ret = unsafe { dest.as_mut_ptr().add(12).cast() };</div>
<div class="line">assert_eq!(ret, expected_ret)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md45"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* src = <span class="stringliteral">&quot;Hello world!&quot;</span>;</div>
<div class="line">    <span class="keywordtype">char</span> dest[13] = {0};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span>* last = <a class="code hl_function" href="string_8h.html#a78660f2f08a94fbb9f194f69b29d26e5">stpcpy</a>(dest, src);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 14; i++) {</div>
<div class="line">        assert(src[i] == dest[i]);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    assert(*last == 0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_a78660f2f08a94fbb9f194f69b29d26e5"><div class="ttname"><a href="string_8h.html#a78660f2f08a94fbb9f194f69b29d26e5">stpcpy</a></div><div class="ttdeci">char * stpcpy(char *dest, const char *src)</div><div class="ttdoc">Copies the characters from the src string to the dest, returning a pointer to the end of the string,...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="abf46d1a41f073640eee9762ebe58f511" name="abf46d1a41f073640eee9762ebe58f511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf46d1a41f073640eee9762ebe58f511">&#9670;&nbsp;</a></span>stpncpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * stpncpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the at least <code>max_size</code> characters from the <code>src</code> string to the <code>dest</code>, returning a pointer to the end of the string, in other words, the first null character. </p>
<h1><a class="anchor" id="autotoc_md46"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>src</code> must be a null terminated string</li>
<li><code>dest</code> must be at least the size of <code>max_size</code> bytes long or the size of <code>src</code> if it is smaller</li>
<li><code>str</code> must be valid for reads for <code>max_size</code> bytes or until the first null character found, whatever is smaller.</li>
<li><code>dest</code> must be valid for writes for <code>max_size</code> bytes or until the <code>str</code> length, whatever is smaller.</li>
<li><code>src</code> and <code>dest</code> must not overlap</li>
</ul>
<h1><a class="anchor" id="autotoc_md47"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md48"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxibot::string::stpcpy;</div>
<div class="line"> </div>
<div class="line">let src = b&quot;Hello World!\0&quot;;</div>
<div class="line">let dest = &amp;mut [0u8; 13];</div>
<div class="line">let ret = unsafe { stpncpy(dest.as_mut_ptr().cast(), src.as_ptr().cast(), 5) };</div>
<div class="line">assert_eq!(b&quot;Hello\0\0\0\0\0\0\0\0&quot;, dest);</div>
<div class="line"> </div>
<div class="line">let expected_ret = unsafe { dest.as_mut_ptr().add(5).cast() };</div>
<div class="line">assert_eq!(ret, expected_ret);</div>
<div class="line"> </div>
<div class="line">unsafe {</div>
<div class="line">    assert_eq!(*ret, 0);</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md49"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* src = <span class="stringliteral">&quot;Hello world!&quot;</span>;</div>
<div class="line">    <span class="keywordtype">char</span> dest[13] = {0};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span>* last = <a class="code hl_function" href="string_8h.html#abf46d1a41f073640eee9762ebe58f511">stpncpy</a>(dest, src, 5);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 5; i++) {</div>
<div class="line">        assert(src[i] == dest[i]);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    assert(*last == 0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_abf46d1a41f073640eee9762ebe58f511"><div class="ttname"><a href="string_8h.html#abf46d1a41f073640eee9762ebe58f511">stpncpy</a></div><div class="ttdeci">char * stpncpy(char *dest, const char *src, size_t max_size)</div><div class="ttdoc">Copies the at least max_size characters from the src string to the dest, returning a pointer to the e...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a19546e43db31c3095991b04023b422b2" name="a19546e43db31c3095991b04023b422b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19546e43db31c3095991b04023b422b2">&#9670;&nbsp;</a></span>strcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strcat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a copy of the <code>src</code> string to the <code>dest</code> string, returning a pointer to the beginning of the <code>dest</code> string. </p>
<h1><a class="anchor" id="autotoc_md50"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>src</code> and <code>dest</code> must be a null terminated strings</li>
<li><code>str</code> must be valid for reads until the first null character found.</li>
<li><code>dest</code> must be valid for writes for <code>strlen(dest)+strlen(src)+1</code> bytes.</li>
<li><code>src</code> and <code>dest</code> must not overlap</li>
</ul>
<h1><a class="anchor" id="autotoc_md51"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md52"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxibot::string::strcat;</div>
<div class="line">let src = b&quot;Hello World!\0&quot;;</div>
<div class="line">let mut dest = *b&quot;I&#39;m part of a test\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;;</div>
<div class="line"> </div>
<div class="line">let ret = unsafe { strcat(dest.as_mut_ptr().cast(), src.as_ptr().cast()) };</div>
<div class="line">assert_eq!(b&quot;I&#39;m part of a testHello World!\0&quot;, &amp;dest);</div>
<div class="line">assert_eq!(ret, dest.as_mut_ptr().cast());</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md53"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* src = <span class="stringliteral">&quot;Hello world!&quot;</span>;</div>
<div class="line">    <span class="keywordtype">char</span> dest[31] = <span class="stringliteral">&quot;I&#39;m part of a test\0\0\0\0\0\0\0\0\0\0\0\0&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span>* ret = <a class="code hl_function" href="string_8h.html#a19546e43db31c3095991b04023b422b2">strcat</a>(dest, src);</div>
<div class="line">    let eq = <a class="code hl_function" href="string_8h.html#a6f3dcb20ff11ff9db5904c3cfb61a38c">strcmp</a>(dest, <span class="stringliteral">&quot;I&#39;m part of a testHello world!&quot;</span>);</div>
<div class="line">    assert(eq == 0);</div>
<div class="line">    assert(ret == dest);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_a19546e43db31c3095991b04023b422b2"><div class="ttname"><a href="string_8h.html#a19546e43db31c3095991b04023b422b2">strcat</a></div><div class="ttdeci">char * strcat(char *dest, const char *src)</div><div class="ttdoc">Appends a copy of the src string to the dest string, returning a pointer to the beginning of the dest...</div></div>
<div class="ttc" id="astring_8h_html_a6f3dcb20ff11ff9db5904c3cfb61a38c"><div class="ttname"><a href="string_8h.html#a6f3dcb20ff11ff9db5904c3cfb61a38c">strcmp</a></div><div class="ttdeci">int strcmp(const char *str1, const char *str2)</div><div class="ttdoc">Compares str1 and str2 null terminated strings lexicographically.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab0592e0e4baf26a4bffbe49168e887fa" name="ab0592e0e4baf26a4bffbe49168e887fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0592e0e4baf26a4bffbe49168e887fa">&#9670;&nbsp;</a></span>strchr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strchr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the first occurrence of a <code>ch</code> in a <code>str</code>, returning a pointer to the found the <code>ch</code> or a null pointer it the <code>ch</code> was not found. </p>
<h1><a class="anchor" id="autotoc_md54"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>str</code> must be a null terminated string</li>
<li><code>str</code> must be valid for reads until the first null character found.</li>
</ul>
<h1><a class="anchor" id="autotoc_md55"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md56"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxilibc::string::strchr;</div>
<div class="line"> </div>
<div class="line">let str = b&quot;Hello, World!\0&quot;;</div>
<div class="line"> </div>
<div class="line">let found_at_ptr = unsafe { strchr(str.as_ptr() as _, b&#39;l&#39; as _) };</div>
<div class="line"> </div>
<div class="line">assert_eq!(found_at_ptr, str[2..].as_ptr() as _);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md57"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> str[] = <span class="stringliteral">&quot;Hello, World!&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span>* ptr = <a class="code hl_function" href="string_8h.html#adea35f46af5016d8f7394c60392edcf3">memchr</a>(str, <span class="charliteral">&#39;l&#39;</span>);</div>
<div class="line">    assert(ptr == str[3]);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6f3dcb20ff11ff9db5904c3cfb61a38c" name="a6f3dcb20ff11ff9db5904c3cfb61a38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3dcb20ff11ff9db5904c3cfb61a38c">&#9670;&nbsp;</a></span>strcmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strcmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares <code>str1</code> and <code>str2</code> null terminated strings lexicographically. </p>
<p >Returning:</p><ul>
<li>Zero if both strings match</li>
<li>A positive number if <code>str1</code> sorts lexicographically after <code>str2</code></li>
<li>A negative number if <code>str1</code> sorts lexicographically before <code>str2</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md58"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>str1</code> must be a null terminated string</li>
<li><code>str2</code> must be a null terminated string</li>
<li><code>str1</code> must be valid for reads until the first null character found.</li>
<li><code>str2</code> must be valid for reads until the first null character found.</li>
</ul>
<h1><a class="anchor" id="autotoc_md59"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md60"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxilibc::string::strcmp;</div>
<div class="line"> </div>
<div class="line">let s1 = b&quot;Hello, World!\0&quot;;</div>
<div class="line">let s2 = b&quot;hello, world!\0&quot;;</div>
<div class="line"> </div>
<div class="line">let test = unsafe { strcmp(s1.as_ptr().cast(), s2.as_ptr().cast()) };</div>
<div class="line">assert_eq!(test, -32);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md61"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* s1 = <span class="stringliteral">&quot;Hello, World!&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* s2 = <span class="stringliteral">&quot;hello, world!&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> cmp = <a class="code hl_function" href="string_8h.html#a6f3dcb20ff11ff9db5904c3cfb61a38c">strcmp</a>(s1, s2);</div>
<div class="line">    assert(cmp == -32)</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac5082c8ce4f0cddd88bf4d0d2e738308" name="ac5082c8ce4f0cddd88bf4d0d2e738308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5082c8ce4f0cddd88bf4d0d2e738308">&#9670;&nbsp;</a></span>strcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the <code>src</code> string, including the null terminator, to the <code>dest</code>, returning <code>dest</code> itself. </p>
<h1><a class="anchor" id="autotoc_md62"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>src</code> must be a null terminated string</li>
<li><code>dest</code> must be at least the size of <code>src</code> long</li>
<li><code>str</code> must be valid for reads until the first null character found.</li>
<li><code>dest</code> must be valid for writes until the <code>str</code> length.</li>
<li><code>src</code> and <code>dest</code> must not overlap</li>
</ul>
<h1><a class="anchor" id="autotoc_md63"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md64"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxibot::string::strcpy;</div>
<div class="line"> </div>
<div class="line">let src = b&quot;Hello World!\0&quot;;</div>
<div class="line">let dest = &amp;mut [0u8; 13];</div>
<div class="line"> </div>
<div class="line">unsafe { strcpy(dest.as_mut_ptr().cast(), src.as_ptr().cast()) };</div>
<div class="line">assert_eq!(src, dest);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md65"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* src = <span class="stringliteral">&quot;Hello world!&quot;</span>;</div>
<div class="line">    <span class="keywordtype">char</span> dest[13] = {0};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="string_8h.html#ac5082c8ce4f0cddd88bf4d0d2e738308">strcpy</a>(dest, src);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 14; i++) {</div>
<div class="line">        assert(src[i] == dest[i]);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_ac5082c8ce4f0cddd88bf4d0d2e738308"><div class="ttname"><a href="string_8h.html#ac5082c8ce4f0cddd88bf4d0d2e738308">strcpy</a></div><div class="ttdeci">char * strcpy(char *dest, const char *src)</div><div class="ttdoc">Copies the src string, including the null terminator, to the dest, returning dest itself.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a28bc3c17235693515008ea0cda14260f" name="a28bc3c17235693515008ea0cda14260f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28bc3c17235693515008ea0cda14260f">&#9670;&nbsp;</a></span>strcspn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> strcspn </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>char_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the maximum initial segment (span) of the byte string pointed to by <code>str</code>, that consists of only the characters <em>not</em> found in the byte string pointed to by <code>char_set</code>. </p>
<h1><a class="anchor" id="autotoc_md66"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>str</code> must be a null terminated string</li>
<li><code>char_set</code> must be a null terminated string</li>
<li><code>str</code> must be valid for reads until the first null character found.</li>
<li><code>char_set</code> must be valid for reads until the first null character found.</li>
</ul>
<h1><a class="anchor" id="autotoc_md67"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md68"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxibot::string::strcspn;</div>
<div class="line"> </div>
<div class="line">let s = b&quot;abcde312$#@\0&quot;;</div>
<div class="line">let pat = b&quot;*$#\0&quot;;</div>
<div class="line"> </div>
<div class="line">let test = unsafe { strcspn(s.as_ptr().cast(), pat.as_ptr().cast()) };</div>
<div class="line">assert_eq!(test, 8);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md69"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keywordtype">string</span> = <span class="stringliteral">&quot;abcde312$#@&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* invalid = <span class="stringliteral">&quot;*$#&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> valid_len = <a class="code hl_function" href="string_8h.html#a28bc3c17235693515008ea0cda14260f">strcspn</a>(<span class="keywordtype">string</span>, low_alpha);</div>
<div class="line">    assert(valid_len == 8);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_a28bc3c17235693515008ea0cda14260f"><div class="ttname"><a href="string_8h.html#a28bc3c17235693515008ea0cda14260f">strcspn</a></div><div class="ttdeci">size_t strcspn(const char *str, const char *char_set)</div><div class="ttdoc">Returns the length of the maximum initial segment (span) of the byte string pointed to by str,...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a008e171a518fe0e0352f31b245e03875" name="a008e171a518fe0e0352f31b245e03875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008e171a518fe0e0352f31b245e03875">&#9670;&nbsp;</a></span>strlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> strlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the given null terminated string <code>str</code>. </p>
<h1><a class="anchor" id="autotoc_md70"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>str</code> must be a null terminated string</li>
<li><code>str</code> must be valid for reads until the first null character found.</li>
</ul>
<h1><a class="anchor" id="autotoc_md71"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md72"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxilibc::string::strlen;</div>
<div class="line"> </div>
<div class="line">let s = b&quot;Hello, World!\0&quot;;</div>
<div class="line">let len = unsafe { strlen(s.as_ptr().cast()) };</div>
<div class="line">assert_eq!(len, 13);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md73"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;Hello, World!&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    assert(<a class="code hl_function" href="string_8h.html#a008e171a518fe0e0352f31b245e03875">strlen</a>(s) == 13);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_a008e171a518fe0e0352f31b245e03875"><div class="ttname"><a href="string_8h.html#a008e171a518fe0e0352f31b245e03875">strlen</a></div><div class="ttdeci">size_t strlen(const char *str)</div><div class="ttdoc">Returns the length of the given null terminated string str.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae917df9af66d8bbc84e3aaeaf8e34d3a" name="ae917df9af66d8bbc84e3aaeaf8e34d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae917df9af66d8bbc84e3aaeaf8e34d3a">&#9670;&nbsp;</a></span>strncat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strncat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a copy of the <code>src</code> string to the <code>dest</code> string for at least <code>max_size</code> characters, returning a pointer to the beginning of the <code>dest</code> string. </p>
<h1><a class="anchor" id="autotoc_md74"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>src</code> and <code>dest</code> must be a null terminated strings</li>
<li><code>str</code> must be valid for reads for <code>max_size</code> characters or until the first null character found, whatever is smaller.</li>
<li><code>dest</code> must be valid for writes for <code>max_size</code> characters or for <code>strlen(dest)+strlen(src)+1</code> characters, whatever is smaller.</li>
<li><code>src</code> and <code>dest</code> must not overlap</li>
</ul>
<h1><a class="anchor" id="autotoc_md75"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md76"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxibot::string::strcat;</div>
<div class="line">let src = b&quot;Hello World!\0&quot;;</div>
<div class="line">let mut dest = *b&quot;I&#39;m part of a test\0\0\0\0\0\0&quot;;</div>
<div class="line"> </div>
<div class="line">let ret = unsafe { strncat(dest.as_mut_ptr().cast(), src.as_ptr().cast(), 5) };</div>
<div class="line">assert_eq!(b&quot;I&#39;m part of a testHello\0&quot;, &amp;dest);</div>
<div class="line">assert_eq!(ret, dest.as_mut_ptr().cast());</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md77"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* src = <span class="stringliteral">&quot;Hello world!&quot;</span>;</div>
<div class="line">    <span class="keywordtype">char</span> dest[31] = <span class="stringliteral">&quot;I&#39;m part of a test\0\0\0\0\0&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span>* ret = <a class="code hl_function" href="string_8h.html#ae917df9af66d8bbc84e3aaeaf8e34d3a">strncat</a>(dest, src, 5);</div>
<div class="line">    let eq = <a class="code hl_function" href="string_8h.html#a6f3dcb20ff11ff9db5904c3cfb61a38c">strcmp</a>(dest, <span class="stringliteral">&quot;I&#39;m part of a testHello&quot;</span>);</div>
<div class="line">    assert(eq == 0);</div>
<div class="line">    assert(ret == dest);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_ae917df9af66d8bbc84e3aaeaf8e34d3a"><div class="ttname"><a href="string_8h.html#ae917df9af66d8bbc84e3aaeaf8e34d3a">strncat</a></div><div class="ttdeci">char * strncat(char *dest, const char *src, size_t max_size)</div><div class="ttdoc">Appends a copy of the src string to the dest string for at least max_size characters,...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a872192e0a38d54c47a8722938d8ce558" name="a872192e0a38d54c47a8722938d8ce558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872192e0a38d54c47a8722938d8ce558">&#9670;&nbsp;</a></span>strncmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strncmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares <code>str1</code> and <code>str2</code> for a maximum of <code>max_size</code> strings lexicographically. </p>
<p >Returning:</p><ul>
<li>Zero if both strings match</li>
<li>A positive number if <code>str1</code> sorts lexicographically after <code>str2</code></li>
<li>A negative number if <code>str1</code> sorts lexicographically before <code>str2</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md78"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>str1</code> must be valid for reads until <code>max_size</code> or the first null character found.</li>
<li><code>str2</code> must be valid for reads until <code>max_size</code> or the first null character found.</li>
</ul>
<h1><a class="anchor" id="autotoc_md79"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md80"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxilibc::string::strncmp;</div>
<div class="line"> </div>
<div class="line">let s1 = b&quot;Hello, World!\0&quot;;</div>
<div class="line">let s2 = b&quot;hello, world!\0&quot;;</div>
<div class="line"> </div>
<div class="line">let test = unsafe { strncmp(s1.as_ptr().cast(), s2.as_ptr().cast(), 5) };</div>
<div class="line">assert!(test &lt; 0);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md81"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* s1 = <span class="stringliteral">&quot;Hello, World!&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* s2 = <span class="stringliteral">&quot;hello, world!&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> cmp = <a class="code hl_function" href="string_8h.html#a872192e0a38d54c47a8722938d8ce558">strncmp</a>(s1, s2, 6);</div>
<div class="line">    assert(cmp &lt; 0)</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_a872192e0a38d54c47a8722938d8ce558"><div class="ttname"><a href="string_8h.html#a872192e0a38d54c47a8722938d8ce558">strncmp</a></div><div class="ttdeci">int strncmp(const char *str1, const char *str2, size_t max_size)</div><div class="ttdoc">Compares str1 and str2 for a maximum of max_size strings lexicographically.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4ba79b932727a6e399a68c3a88dcfa93" name="a4ba79b932727a6e399a68c3a88dcfa93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba79b932727a6e399a68c3a88dcfa93">&#9670;&nbsp;</a></span>strncpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strncpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the at least <code>max_size</code> characters from the <code>src</code> string to the <code>dest</code>, returning <code>dest</code> itself. </p>
<p >If a null character is found on <code>src</code> before reaching the <code>max_size</code> character, additional null characters are added up to the <code>max_size</code></p>
<h1><a class="anchor" id="autotoc_md82"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>src</code> must be valid for reads until <code>max_size</code> or the first null character found.</li>
<li><code>dest</code> must be valid for writes until <code>max_size</code></li>
<li><code>src</code> and <code>dest</code> must not overlap</li>
</ul>
<h1><a class="anchor" id="autotoc_md83"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md84"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxibot::string::strncpy;</div>
<div class="line"> </div>
<div class="line">let src = b&quot;Hello World!\0&quot;;</div>
<div class="line">let dest = &amp;mut [1u8; 14];</div>
<div class="line"> </div>
<div class="line">unsafe { strncpy(dest.as_mut_ptr().cast(), src.as_ptr().cast(), 14) };</div>
<div class="line">assert_eq!(src, &amp;dest[..13]);</div>
<div class="line">assert_eq!(b&quot;Hello World!\0\0&quot;, dest);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md85"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* src = <span class="stringliteral">&quot;Hello world!&quot;</span>;</div>
<div class="line">    <span class="keywordtype">char</span> dest[14] = {0};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="string_8h.html#a4ba79b932727a6e399a68c3a88dcfa93">strncpy</a>(dest, src, 14);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 14; i++) {</div>
<div class="line">        assert(src[i] == dest[i]);</div>
<div class="line">    }</div>
<div class="line">    assert(dest[14] == 0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_a4ba79b932727a6e399a68c3a88dcfa93"><div class="ttname"><a href="string_8h.html#a4ba79b932727a6e399a68c3a88dcfa93">strncpy</a></div><div class="ttdeci">char * strncpy(char *dest, const char *src, size_t max_size)</div><div class="ttdoc">Copies the at least max_size characters from the src string to the dest, returning dest itself.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af1bb92bca4cc2ef4c7b93550270a949c" name="af1bb92bca4cc2ef4c7b93550270a949c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bb92bca4cc2ef4c7b93550270a949c">&#9670;&nbsp;</a></span>strnlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> strnlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A safer version of [strlen]. </p>
<p >This function returns:</p><ul>
<li><code>max_size</code> if no null character was found up to that point</li>
<li>The length of <code>str</code> if a null character was found before reaching the <code>max_size</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md86"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>str</code> must be valid for reads until <code>max_size</code> or the first null character found.</li>
</ul>
<h1><a class="anchor" id="autotoc_md87"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md88"></a>
Rust</h2>
<div class="fragment"><div class="line">use core::ptr;</div>
<div class="line">use oxilibc::string::strnlen;</div>
<div class="line"> </div>
<div class="line">let s = b&quot;Hello, World!\0&quot;;</div>
<div class="line">let len = unsafe { strnlen(s.as_ptr().cast(), 14) };</div>
<div class="line">assert_eq!(len, 13);</div>
<div class="line"> </div>
<div class="line">let len = unsafe { strnlen(s.as_ptr().cast(), 7) };</div>
<div class="line">assert_eq!(len, 7);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md89"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;Hello, World!&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    assert(<a class="code hl_function" href="string_8h.html#af1bb92bca4cc2ef4c7b93550270a949c">strnlen</a>(s, 14) == 13);</div>
<div class="line">    assert(<a class="code hl_function" href="string_8h.html#af1bb92bca4cc2ef4c7b93550270a949c">strnlen</a>(s, 7) == 7);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_af1bb92bca4cc2ef4c7b93550270a949c"><div class="ttname"><a href="string_8h.html#af1bb92bca4cc2ef4c7b93550270a949c">strnlen</a></div><div class="ttdeci">size_t strnlen(const char *str, size_t max_size)</div><div class="ttdoc">A safer version of [strlen].</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3135fe411f8507e490704184fbecc697" name="a3135fe411f8507e490704184fbecc697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3135fe411f8507e490704184fbecc697">&#9670;&nbsp;</a></span>strnlen_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> strnlen_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A safer version of [strlen]. </p>
<p >This function returns:</p><ul>
<li>Zero if <code>str</code> is a null pointer</li>
<li><code>max_size</code> if no null character was found up to that point</li>
<li>The length of <code>str</code> if a null character was found before reaching the <code>max_size</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md90"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>str</code> must be valid for reads until <code>max_size</code> or the first null character found.</li>
</ul>
<h1><a class="anchor" id="autotoc_md91"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md92"></a>
Rust</h2>
<div class="fragment"><div class="line">use core::ptr;</div>
<div class="line">use oxilibc::string::strnlen_s;</div>
<div class="line"> </div>
<div class="line">let s = b&quot;Hello, World!\0&quot;;</div>
<div class="line">let len = unsafe { strnlen_s(s.as_ptr().cast(), 14) };</div>
<div class="line">assert_eq!(len, 13);</div>
<div class="line"> </div>
<div class="line">let len = unsafe { strnlen_s(ptr::null(), 5) };</div>
<div class="line">assert_eq!(len, 0);</div>
<div class="line"> </div>
<div class="line">let len = unsafe { strnlen_s(s.as_ptr().cast(), 7) };</div>
<div class="line">assert_eq!(len, 7);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md93"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* s = <span class="stringliteral">&quot;Hello, World!&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    assert(<a class="code hl_function" href="string_8h.html#a3135fe411f8507e490704184fbecc697">strnlen_s</a>(s, 14) == 13);</div>
<div class="line">    assert(<a class="code hl_function" href="string_8h.html#a3135fe411f8507e490704184fbecc697">strnlen_s</a>(NULL, 5) == 0);</div>
<div class="line">    assert(<a class="code hl_function" href="string_8h.html#a3135fe411f8507e490704184fbecc697">strnlen_s</a>(s, 7) == 7);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_a3135fe411f8507e490704184fbecc697"><div class="ttname"><a href="string_8h.html#a3135fe411f8507e490704184fbecc697">strnlen_s</a></div><div class="ttdeci">size_t strnlen_s(const char *str, size_t max_size)</div><div class="ttdoc">A safer version of [strlen].</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7662d17f7904c19e871728691d0cb303" name="a7662d17f7904c19e871728691d0cb303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7662d17f7904c19e871728691d0cb303">&#9670;&nbsp;</a></span>strrchr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strrchr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the last occurrence of a <code>ch</code> in a <code>str</code>, returning a pointer to the found the <code>ch</code> or a null pointer it the <code>ch</code> was not found. </p>
<h1><a class="anchor" id="autotoc_md94"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>str</code> must be a null terminated string</li>
<li><code>str</code> must be valid for reads until the first null character found.</li>
</ul>
<h1><a class="anchor" id="autotoc_md95"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md96"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxilibc::string::strrchr;</div>
<div class="line"> </div>
<div class="line">let str = b&quot;Hello, World!\0&quot;;</div>
<div class="line"> </div>
<div class="line">let found_at_ptr = unsafe { strrchr(str.as_ptr() as _, b&#39;l&#39; as _) };</div>
<div class="line"> </div>
<div class="line">assert_eq!(found_at_ptr, str[10..].as_ptr() as _);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md97"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> str[] = <span class="stringliteral">&quot;Hello, World!&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span>* ptr = <a class="code hl_function" href="string_8h.html#adea35f46af5016d8f7394c60392edcf3">memchr</a>(str, <span class="charliteral">&#39;l&#39;</span>);</div>
<div class="line">    assert(ptr == str[10]);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a06aea5f2e42c34e773726a0031c7a19f" name="a06aea5f2e42c34e773726a0031c7a19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06aea5f2e42c34e773726a0031c7a19f">&#9670;&nbsp;</a></span>strspn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="target_2include_2stddef_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> strspn </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>char_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the maximum initial segment (span) of the byte string pointed to by <code>str</code>, that consists of only the characters found in the byte string pointed to by <code>char_set</code>. </p>
<h1><a class="anchor" id="autotoc_md98"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>str</code> must be a null terminated string</li>
<li><code>char_set</code> must be a null terminated string</li>
<li><code>str</code> must be valid for reads until the first null character found.</li>
<li><code>char_set</code> must be valid for reads until the first null character found.</li>
</ul>
<h1><a class="anchor" id="autotoc_md99"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md100"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxibot::string::strspn;</div>
<div class="line"> </div>
<div class="line">let s = b&quot;abcde312$#@\0&quot;;</div>
<div class="line">let pat = b&quot;qwertyuiopasdfghjklzxcvbnm\0&quot;;</div>
<div class="line"> </div>
<div class="line">let test = unsafe { strspn(s.as_ptr().cast(), pat.as_ptr().cast()) };</div>
<div class="line">assert_eq!(test, 5);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md101"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span> = <span class="stringliteral">&quot;abcde312$#@&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *low_alpha = <span class="stringliteral">&quot;qwertyuiopasdfghjklzxcvbnm&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> spnsz = <a class="code hl_function" href="string_8h.html#a06aea5f2e42c34e773726a0031c7a19f">strspn</a>(<span class="keywordtype">string</span>, low_alpha);</div>
<div class="line">    assert(spnsz == 5);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_a06aea5f2e42c34e773726a0031c7a19f"><div class="ttname"><a href="string_8h.html#a06aea5f2e42c34e773726a0031c7a19f">strspn</a></div><div class="ttdeci">size_t strspn(const char *str, const char *char_set)</div><div class="ttdoc">Returns the length of the maximum initial segment (span) of the byte string pointed to by str,...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6e41d07110225e8405824ae1cfb26c66" name="a6e41d07110225e8405824ae1cfb26c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e41d07110225e8405824ae1cfb26c66">&#9670;&nbsp;</a></span>strstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strstr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the first occurrence of a <code>pattern</code> in a <code>src</code>, returning a pointer to the first character of the found the <code>pattern</code> or a null pointer it the <code>pattern</code> was not found. </p>
<h1><a class="anchor" id="autotoc_md102"></a>
Safety</h1>
<p >Behavior is undefined if any of the following conditions are violated:</p><ul>
<li><code>src</code> and <code>pattern</code> must be null terminated strings</li>
<li><code>src</code> must be valid for reads until the first null character found.</li>
<li><code>pattern</code> must be valid for reads until the first null character found.</li>
</ul>
<h1><a class="anchor" id="autotoc_md103"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md104"></a>
Rust</h2>
<div class="fragment"><div class="line">use oxibot::string::strstr;</div>
<div class="line"> </div>
<div class="line">let src = b&quot;Hello World!\0&quot;;</div>
<div class="line">let pat = b&quot;World\0&quot;;</div>
<div class="line"> </div>
<div class="line">let res = unsafe { strstr(src.as_ptr().cast(), pat.as_ptr().cast()) };</div>
<div class="line">assert_eq!(unsafe { src.as_ptr().cast::&lt;i8&gt;().add(6) }, res);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md105"></a>
C</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* src = <span class="stringliteral">&quot;Hello world!&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* pat = <span class="stringliteral">&quot;world&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span>* res = <a class="code hl_function" href="string_8h.html#a6e41d07110225e8405824ae1cfb26c66">strstr</a>(src, pat);</div>
<div class="line"> </div>
<div class="line">    assert(src[6] == res);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astring_8h_html_a6e41d07110225e8405824ae1cfb26c66"><div class="ttname"><a href="string_8h.html#a6e41d07110225e8405824ae1cfb26c66">strstr</a></div><div class="ttdeci">char * strstr(const char *str, const char *pattern)</div><div class="ttdoc">Search for the first occurrence of a pattern in a src, returning a pointer to the first character of ...</div></div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_1bbcb9615bce09de8292fb64e7b04403.html">target</a></li><li class="navelem"><a class="el" href="dir_7db0c2058728c0cc11dd629f56b2188c.html">include</a></li><li class="navelem"><a class="el" href="string_8h.html">string.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
